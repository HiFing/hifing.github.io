---
title: "MySQL事务与锁"
description: 
date: 2023-04-21T14:47:17+08:00
image: 
math: 
license: 
hidden: false
comments: true
draft: false
categories:
  - MySQL
---
# MySQL事务与锁

## 事务

### 事务特性与隔离级别

#### ACID
* 原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。（undo log保证）
* 一致性（Consistency）：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。（通过A、I、D保证）
* 隔离性（Isolation）：多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。（MVCC或锁保证）
* 持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。（通过redo log保证）

#### 隔离级别
* 并行事务处理时会发生的现象：脏读、不可重复读、幻读
  * 脏读：事务A读到了事务B未提交的数据。
  * 不可重复读：在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了不可重复读现象。
  * 幻读：在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了幻读现象。
  
* 四个隔离级别
  * 读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；（会出现脏读、不可重复读、幻读）
  * 读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；（会出现不可重复读、幻读）
  * **可重复读**（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；（会出现幻读）
  * 串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；
  > TIP
  >
  > 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同。**「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View**，然后整个事务期间都在用这个 Read View。

* MySQL的可重复读隔离级别对幻读的处理（不能完全避免）
  * 针对**快照读**（普通 select 语句）：通过 MVCC 方式解决了幻读；
  * 针对**当前读**（select ... for update 等语句）：通过 next-key lock（记录锁+间隙锁）方式解决了幻读。
  > TIP
  >
  > 什么情况下还是会出现幻读？
  > case 1:![](../../assets/img/幻读发生1.drawio.webp)
  > case 2:
  >* T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id > 100 得到了 3 条记录。
  >* T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；
  >* T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id > 100 for update 就会得到 4 条记录，此时也发生了幻读现象。
要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。

#
  
### ReadView和MVCC
ReadView结构：
<div align="center"><img width=400px src=../../assets/img/readview结构.webp /></div>

> TIP
>
> 一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：
> * 如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见。
> * 如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。
> * 如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中：
>   * 如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。
>   * 如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。

聚簇索引隐藏列：
<div align="center"><img width=400px src=../../assets/img/隐藏列.webp /></div>

> roll_ptr指向下一条undo log，下一条undo log也是这样的结构，这样，就构成了一条版本链。

## 锁

### MySQL有哪些锁