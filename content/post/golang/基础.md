---
title: "Golang基础"
description: 
date: 2023-04-29T17:59:47+08:00
image: 
math: 
license: 
hidden: false
comments: true
draft: false
categories:
  - Golang
---
# Golang基础

## 基础知识合集

### unsafe
Unsafe code是一种绕过go类型安全和内存安全检查的Go代码。大多数情况，unsafe code是和指针相关的。
  ```go
  func main() {
    array := [...]int{1, 2, 3, 4, 5}
    ptr := &array[0]
    baseAddr := uintptr(unsafe.Pointer(ptr))
    for i := 0; i < len(array)-1; i++ {
      baseAddr += unsafe.Sizeof(array[0])
      ptr := (*int)(unsafe.Pointer(baseAddr))
      fmt.Println(*ptr)
    }
    baseAddr += (unsafe.Sizeof(array[0]) + unsafe.Sizeof(array[0]) + unsafe.Sizeof(array[0])) + unsafe.Sizeof(array[0])
    ptr = (*int)(unsafe.Pointer(baseAddr))
    fmt.Println(*ptr)
  }
  ---
  2
  3
  4
  5
  4307106152 // a random number, 超过范围后输出了一些不可预料的值
  ```

### Go与C语言互调的方式
  #### C中调用Go代码
  * 在Go文件中编写好被调用的代码
    ```go
    //导入"C"包
    import "C"
    import "fmt"

    //加export注释后才能被识别，注意斜杠和export之间没有空格！

    //export PrintMsg 
    func PrintMsg() {
      fmt.Println("Let's Go!")
    }

    //export Mul
    func Mul(a, b int) int {
      return a * b
    }
    ```
  * `go build -o usedByC.o -buildmode=c-shared usedByC.go`
    执行完成后会有`.h`文件和`.o`文件。
  * 使用导出的模块
    ```c
    #include <stdio.h>
    #include "usedByC.h"

    int main(int argc, char **argv) {
      GoInt x = 12; //头文件中的定义：typedef GoInt64 GoInt;
      GoInt y = 23;
      printf("Call PrintMsg in C!\n");
      PrintMsg();
      GoInt p = Mul(x, y);
      printf("Call Mul in C! The value is %d\n", (int)p);
      return 0;
    }
    ```
  * 生成二进制可执行文件并执行程序
    `gcc -o willUseGo willUseGo.c ./usedByC.o`
    `./willUseGo`

  #### Go中调用C代码
  * 代码嵌套
    ```go
      package main
      /*
      // C 标志io头文件，你也可以使用里面提供的函数
      #include <stdio.h>

      void pri(){
        printf("hey\n");
      }

      int add(int a,int b){
        return a+b;
      }
      */
      import "C" // 切勿换行再写这个

      import "fmt"

      func main() {
        fmt.Println(C.add(2, 1))
        C.pri()
      }
    ```
  * 导入动态库（最安全、最麻烦）
  * 直接引用（其实就是将嵌套代码挂出去了，然后在go文件中嵌套少许引用代码即可，非常简洁）
    ```go
    package util

    /*
    #include "util.h"
    */
    import "C"

    func Sum(a, b int) int {
      s := C.sum(C.int(a), C.int(b))
      return (int)(s)
    }
    ```
    在c文件这边：
    ```c
    //.h
    int sum(int a,int b);
    //.c
    #include "util.h"
    int sum(int a, int b) { return (a + b); }
    ```
    最后在main函数里：
    ```go
    package main

    import (
      "fmt"

      "barry.com/master/util"
    )

    func main() {
      fmt.Println(util.Sum(4, 5))
    }

    //输出：9
    ```


### defer，panic，recover
* defer函数在外围函数返回之后，以后进先出(LIFO)的原则执行。
* 使用defer语句时遇到的坑
  函数返回的过程是这样的：**先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中**。（因为：return xxx语句并不是一条原子指令）
  ```go
  func f() (r int) {
    t := 5
    defer func() {
      t = t + 5
    }()
    return t // 相当于 r=t; return;
  }

  // r:=t; t+=5; return r

  func main() {
    fmt.Println(f())
  }

  // 输出：5

  ---

  func t1() {
    i := 0
    defer fmt.Println(i)  //引用的外部参数会立刻被拷贝
    i++
  }

  // 输出：0

  ---

  func t2() {
    i := 0
    defer func() {        //函数被延迟执行
      fmt.Println(i)
    }()
    i++
  }

  // 输出：1

  ```
* panic 只会保证当前 goroutine 中的 defer 代码一定会执行，其他 goroutine 中的 defer 代码不保证能执行。
  ```go
  func main() {
    go func() {
      defer fmt.Println("goroutine1 invoke")
      go func() {
        defer fmt.Println("goroutine2 invoke")
        go func() {
          defer fmt.Println("goroutine3 invoke")
          panic("panic")
        }()
      }()
    }()

    time.Sleep(1 * time.Second)
  }

  ---
  goroutine1 invoke
  goroutine2 invoke
  goroutine3 invoke
  panic: panic


  goroutine1 invoke
  goroutine3 invoke
  goroutine2 invoke
  panic: panic


  goroutine3 invoke
  panic: panic
  ```

* recover都是在当前的goroutine里进行捕获的，这就是说，对于创建goroutine的外层函数，如果goroutine内部发生panic并且内部没有用recover，外层函数是无法用recover来捕获的，这样会造成程序崩溃。（其他 goroutine 中的 defer 代码不保证能执行）
  ```go
  func main() {
    defer func() { // 直接崩溃不执行
      fmt.Println("trying to stop main")
      if c := recover(); c != nil {
        fmt.Println("panic caught")
      }
    }()

    go func() {
      defer func() {
        fmt.Println("inner stopped")
      }()
      panic("OK?")
    }()

    time.Sleep(1 * time.Second)
    fmt.Println("OK, main stopped safely")
  }

  ---

  inner stopped
  panic: OK?

  goroutine 4 [running]:
  main.main.func2()
    xxx/main.go:20 +0x48
  created by main.main
    xxx/main.go:16 +0x40
  exit status 2
  ```

* recover返回的是interface{}类型而不是go中的 error 类型，如果外层函数需要调用err.Error()，会编译错误，也可能会在执行时panic。
  ```go
  func main() {
    defer func() {
      if err := recover(); err != nil {
        fmt.Println("捕获异常:", err.(error))
      }
    }()
    panic("a")
  }

  ---
  panic: a [recovered]
    panic: interface conversion: string is not error: missing method Error
  ```


### 闭包
todo

### 切片
* Go方法传参为值传参，关于slice、map、chan的传参效果同引用传参相同的问题，主要是因为slice为一个struct，里面包含了一个底层数组的指针、len、cap，当传参为slice时，拷贝整个struct，其中，指针所指的底层数组不变，因此，在接受传参的方法中修改slice的底层数组会影响到外部slice的底层数组；map和chan的原理类似，都是指针类型，因此传参传的是地址。

  ```go
  func main() {
  	// array := []int{7, 8, 9}
  	array := make([]int, 3, 4)
  	array[0] = 7
  	array[1] = 8
  	array[2] = 9
  	fmt.Printf("main ap brfore: len: %d cap:%d data:%+v\n", len(array), cap(array), array)
  	ap(array)
  	fmt.Printf("main ap after: len: %d cap:%d data:%+v\n", len(array), cap(array), array)
  	array = array[0:4]
  	fmt.Printf("main ap after: len: %d cap:%d data:%+v\n", len(array), cap(array), array)
  }
  
  func ap(array []int) {
  	fmt.Printf("ap brfore:  len: %d cap:%d data:%+v\n", len(array), cap(array), array)
  	array = append(array, 10)
  	array[0] = 1
  	fmt.Printf("ap after:   len: %d cap:%d data:%+v\n", len(array), cap(array), array)
  }
  
  ---
  main ap brfore: len: 3 cap:4 data:[7 8 9]
  ap brfore:  len: 3 cap:4 data:[7 8 9]
  ap after:   len: 4 cap:4 data:[1 8 9 10]
  main ap after: len: 3 cap:4 data:[1 8 9]
  main ap after: len: 4 cap:4 data:[1 8 9 10]
  ```

  [java - go语言参数传递到底是传值还是传引用？ - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000037763005)


## Go并发编程
### 开源包ants学习



## Leetcode刷题相关
* golang堆实现：
  
  ```go
  //小顶堆Demo
  import (
    "container/heap"
    "fmt"
  )

  type ListNode struct {
    Val  int
    Next *ListNode
  }

  type NodeHeap []*ListNode

  func (nh NodeHeap) Less(i, j int) bool  { return nh[i].Val < nh[j].Val } //大顶堆就改成大于号
  func (nh NodeHeap) Swap(i, j int)       { nh[i], nh[j] = nh[j], nh[i] }
  func (nh NodeHeap) Len() int            { return len(nh) }
  func (nh *NodeHeap) Push(x interface{}) { *nh = append(*nh, x.(*ListNode)) }

  //注意Pop的写法！！！
  func (nh *NodeHeap) Pop() interface{} {
    old := *nh
    res := old[len(old)-1] //取出lastOne，但是对于切片来说是去除头一个，即堆顶元素
    *nh = old[:len(old)-1]
    return res
  }

  func mergeKLists(lists []*ListNode) *ListNode {
    h := NodeHeap{}
    heap.Init(&h)
    for i := 0; i < len(lists); i++ {
      head := lists[i]
      for head != nil {
        heap.Push(&h, head)
        head = head.Next
      }
    }
    blank := new(ListNode)
    follower := blank
    for i := 0; i < len(h); i++ {
      fmt.Print(h[i].Val, " ")
    }
    for len(h) > 0 {
      follower.Next = heap.Pop(&h).(*ListNode)
      follower = follower.Next
    }
    follower.Next = nil
    return blank.Next
  }
  ```