<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>MySQL on Welcome to Barry&#39;s Blog</title>
        <link>https://hifing.github.io/categories/mysql/</link>
        <description>Recent content in MySQL on Welcome to Barry&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 21 Apr 2023 14:47:17 +0800</lastBuildDate><atom:link href="https://hifing.github.io/categories/mysql/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>MySQL事务与锁</title>
        <link>https://hifing.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81/</link>
        <pubDate>Fri, 21 Apr 2023 14:47:17 +0800</pubDate>
        
        <guid>https://hifing.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81/</guid>
        <description>&lt;h1 id=&#34;mysql事务与锁&#34;&gt;MySQL事务与锁&lt;/h1&gt;
&lt;h2 id=&#34;事务&#34;&gt;事务&lt;/h2&gt;
&lt;h3 id=&#34;事务特性与隔离级别&#34;&gt;事务特性与隔离级别&lt;/h3&gt;
&lt;h4 id=&#34;acid&#34;&gt;ACID&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。（undo log保证）&lt;/li&gt;
&lt;li&gt;一致性（Consistency）：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。（通过A、I、D保证）&lt;/li&gt;
&lt;li&gt;隔离性（Isolation）：多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。（MVCC或锁保证）&lt;/li&gt;
&lt;li&gt;持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。（通过redo log保证）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;隔离级别&#34;&gt;隔离级别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;并行事务处理时会发生的现象：脏读、不可重复读、幻读&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脏读：事务A读到了事务B未提交的数据。&lt;/li&gt;
&lt;li&gt;不可重复读：在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了不可重复读现象。&lt;/li&gt;
&lt;li&gt;幻读：在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了幻读现象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;四个隔离级别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；（会出现脏读、不可重复读、幻读）&lt;/li&gt;
&lt;li&gt;读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；（会出现不可重复读、幻读）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可重复读&lt;/strong&gt;（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；（会出现幻读）&lt;/li&gt;
&lt;li&gt;串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;TIP&lt;/p&gt;
&lt;p&gt;对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同。&lt;strong&gt;「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View&lt;/strong&gt;，然后整个事务期间都在用这个 Read View。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL的可重复读隔离级别对幻读的处理（不能完全避免）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对&lt;strong&gt;快照读&lt;/strong&gt;（普通 select 语句）：通过 MVCC 方式解决了幻读；&lt;/li&gt;
&lt;li&gt;针对&lt;strong&gt;当前读&lt;/strong&gt;（select &amp;hellip; for update 等语句）：通过 next-key lock（记录锁+间隙锁）方式解决了幻读。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;TIP&lt;/p&gt;
&lt;p&gt;什么情况下还是会出现幻读？
case 1:&lt;img src=&#34;https://hifing.github.io/assets/img/%e5%b9%bb%e8%af%bb%e5%8f%91%e7%94%9f1.drawio.webp&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
case 2:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &amp;gt; 100 得到了 3 条记录。&lt;/li&gt;
&lt;li&gt;T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；&lt;/li&gt;
&lt;li&gt;T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &amp;gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。
要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select &amp;hellip; for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;readview和mvcc&#34;&gt;ReadView和MVCC&lt;/h3&gt;
&lt;p&gt;ReadView结构：&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;&lt;img width=400px src=../../assets/img/readview结构.webp /&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;TIP&lt;/p&gt;
&lt;p&gt;一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见。&lt;/li&gt;
&lt;li&gt;如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。&lt;/li&gt;
&lt;li&gt;如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中：
&lt;ul&gt;
&lt;li&gt;如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。&lt;/li&gt;
&lt;li&gt;如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;聚簇索引隐藏列：&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt;&lt;img width=400px src=../../assets/img/隐藏列.webp /&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;roll_ptr指向下一条undo log，下一条undo log也是这样的结构，这样，就构成了一条版本链。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;锁&#34;&gt;锁&lt;/h2&gt;
&lt;h3 id=&#34;mysql有哪些锁&#34;&gt;MySQL有哪些锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;全局锁&lt;/li&gt;
&lt;li&gt;表级锁
&lt;ul&gt;
&lt;li&gt;表锁&lt;/li&gt;
&lt;li&gt;元数据锁：MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的，这主要是考虑到长事务中对数据表的结构修改会影响其他事务的执行。（读读兼容、读写互斥、写写互斥）&lt;/li&gt;
&lt;li&gt;意向锁：对表内某些记录加&lt;strong&gt;行级&lt;/strong&gt;读写锁之前会先申请&lt;strong&gt;表级意向锁&lt;/strong&gt;。意向锁的目的是为了快速判断表里是否有记录被加锁。
意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且&lt;strong&gt;意向锁之间也不会发生冲突&lt;/strong&gt;，只会和表读锁和表写锁发生冲突。&lt;/li&gt;
&lt;li&gt;AUTO-INC锁：表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;行级锁
InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。
&lt;ul&gt;
&lt;li&gt;Record Lock&lt;/li&gt;
&lt;li&gt;Gap Lock&lt;/li&gt;
&lt;li&gt;Nexy-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。&lt;/li&gt;
&lt;li&gt;插入意向锁（注意和表级锁中的意向锁进行区分）：它是一种&lt;strong&gt;特殊的间隙锁&lt;/strong&gt;，属于行级别锁。两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mysql是怎么加锁的&#34;&gt;MySQL是怎么加锁的&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/mysql/lock/how_to_lock.html#mysql-%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;几个案例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意非唯一索引加锁情况。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;select * from user where age &amp;gt;= 22  for update;
&lt;img src=&#34;https://hifing.github.io/assets/img/%e9%9d%9e%e5%94%af%e4%b8%80%e7%b4%a2%e5%bc%95%e8%8c%83%e5%9b%b4%e6%9f%a5%e8%af%a2age%e5%a4%a7%e4%ba%8e%e7%ad%89%e4%ba%8e22.drawio.webp&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;TIP&lt;/p&gt;
&lt;p&gt;MySQL 行级锁的加锁规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;唯一索引等值查询：
当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成「记录锁」。
当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会退化成「间隙锁」。&lt;/li&gt;
&lt;li&gt;非唯一索引等值查询：
当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的&lt;strong&gt;主键索引上加记录锁&lt;/strong&gt;。
当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;mysql死锁了怎么办&#34;&gt;MySQL死锁了怎么办&lt;/h3&gt;
&lt;h4 id=&#34;原因&#34;&gt;原因&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;间隙锁&lt;/strong&gt;的意义只在于阻止区间被插入，因此是可以共存的。一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁。
这里的共同间隙包括两种场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其一是两个间隙锁的间隙区间完全一样；&lt;/li&gt;
&lt;li&gt;其二是一个间隙锁包含的间隙区间是另一个间隙锁包含间隙区间的子集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是有一点要注意，&lt;strong&gt;next-key lock 是包含间隙锁+记录锁的&lt;/strong&gt;，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的，即记录锁要考虑 X 型与 S 型关系。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/mysql/lock/deadlock.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;死锁案例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待&lt;strong&gt;其它事务&lt;/strong&gt;释放间隙锁之后，才能获取到插入意向锁。间隙锁与间隙锁之间是兼容的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;插入意向锁只在&lt;strong&gt;并发插入&lt;/strong&gt;时会用到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;死锁避免&#34;&gt;死锁避免&lt;/h4&gt;
&lt;p&gt;死锁的四个必要条件：&lt;strong&gt;互斥、占有且等待、不可强占用、循环等待&lt;/strong&gt;。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。
因此可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置事务超时时间&lt;/li&gt;
&lt;li&gt;开启主动死锁检测&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>MySQL基础</title>
        <link>https://hifing.github.io/p/mysql%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Fri, 21 Apr 2023 14:47:17 +0800</pubDate>
        
        <guid>https://hifing.github.io/p/mysql%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;h1 id=&#34;mysql结构&#34;&gt;MySQL结构&lt;/h1&gt;
&lt;p&gt;MySQL的一个设计思想：&lt;strong&gt;如果内存够用，就要多利用内存，尽量减少磁盘访问&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://hifing.github.io/assets/img/java/mysqlprocess.webp&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;MySQL结构图&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;一条select语句的执行流程&#34;&gt;一条select语句的执行流程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连接器&lt;/strong&gt;负责与客户端进行TCP三次握手，校验用户名密码，读取用户身份与操作权限。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;此处的查询缓存是在Server层执行的，并不是存储引擎中的buffer pool&lt;/strong&gt;。当数据表频繁更新，或者查询的数据非常庞大时，缓存命中率可能不会很高，考虑到Server层的缓存实用性不大，因此，从MySQL 8.0 开始，执行一条 SQL 查询语句，不会再在Server层中执行查询缓存的步骤了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在执行SQL语句前，先由&lt;strong&gt;解析器&lt;/strong&gt;对SQL语句进行解析，该步骤分为词法分析和语法分析。其中，在词法分析时，MySQL根据SQL关键词构建SQL语法树；语法分析时，解析器会根据语法规则，判断输入的 SQL 语句&lt;strong&gt;是否满足 MySQL 语法&lt;/strong&gt;，比如，把&lt;code&gt;from&lt;/code&gt;写成&lt;code&gt;form&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在执行SQL语句时，会分为以下三个阶段：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;预处理：检查SQL中的&lt;strong&gt;表或者字段是否存在&lt;/strong&gt;，将&lt;code&gt;*&lt;/code&gt;扩展为表上所有的列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优化：优化器负责将SQL查询语句的执行方案确定下来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行：（以&lt;code&gt;select * from product where id = 1;&lt;/code&gt;为例）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优化的访问类型为const（常量查询，此外还有all、range等），首次查询调用&lt;code&gt;read_first_record&lt;/code&gt;函数指针指向的函数，让存储引擎读取符合条件的第一条记录；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过主键索引的B+树定位第一条记录；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行器（Server层）判断记录是否符合查询条件；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询过程为while循环，调用&lt;code&gt;read_record&lt;/code&gt;函数指针指向的函数，因为是const访问类型，该指针指向-1，查询结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;索引下推对执行阶段的优化&#34;&gt;索引下推对执行阶段的优化&lt;/h3&gt;
&lt;p&gt;使用索引下推（MySQL 5.6 以后）能&lt;strong&gt;减少二级索引在查询时的回表操作&lt;/strong&gt;，提高效率，它将Server层部分负责的任务&lt;strong&gt;交给引擎层去处理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;select * from t_user where age &amp;gt; 20 and reward = 100000;&lt;/code&gt;为例（已建立&lt;code&gt;age&lt;/code&gt;和&lt;code&gt;reward&lt;/code&gt;的联合索引）：&lt;/p&gt;
&lt;p&gt;联合索引遇到范围查找会停止匹配，此SQL仅&lt;code&gt;age&lt;/code&gt;能使用联合索引，当开启索引下推时，根据二级索引查询获取到的一条记录，引擎层直接判断&lt;code&gt;reward&lt;/code&gt;是否符合条件，若不符合，则直接舍弃。（若不开启，则需要先进行&lt;strong&gt;回表&lt;/strong&gt;操作，把完整数据反馈至Server层，由Server层判断）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;innodb和myisam的不同&#34;&gt;InnoDB和MyISAM的不同&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MyISAM 只有表级锁，而 &lt;strong&gt;InnoDB 支持行级锁和表级锁&lt;/strong&gt;，默认为行级锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MyISAM 不提供&lt;strong&gt;事务&lt;/strong&gt;支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交和回滚事务的能力。并且，InnoDB 默认使用的可重读隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MyISAM 不支持&lt;strong&gt;外键&lt;/strong&gt;，而 InnoDB 支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 &lt;code&gt;redo log&lt;/code&gt; 。MyISAM不支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。&lt;/p&gt;
&lt;p&gt;InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>MySQL日志</title>
        <link>https://hifing.github.io/p/mysql%E6%97%A5%E5%BF%97/</link>
        <pubDate>Fri, 21 Apr 2023 14:47:17 +0800</pubDate>
        
        <guid>https://hifing.github.io/p/mysql%E6%97%A5%E5%BF%97/</guid>
        <description></description>
        </item>
        <item>
        <title>MySQL索引</title>
        <link>https://hifing.github.io/p/mysql%E7%B4%A2%E5%BC%95/</link>
        <pubDate>Fri, 21 Apr 2023 14:47:17 +0800</pubDate>
        
        <guid>https://hifing.github.io/p/mysql%E7%B4%A2%E5%BC%95/</guid>
        <description>&lt;h1 id=&#34;mysql索引&#34;&gt;MySQL索引&lt;/h1&gt;
&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;几种数据结构对比&lt;/strong&gt;：&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/27700617&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;平衡二叉树、B树、B+树、B*树介绍&lt;/a&gt; 与 &lt;a class=&#34;link&#34; href=&#34;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;演示链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回表&lt;/strong&gt;：查询二级索引时将会得到主键值，根据主键值查询主键索引才能得到整行数据，这个过程叫做回表，即需要查询这两个B+树才能得到数据本身。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;覆盖查找&lt;/strong&gt;：如SQL语句&lt;code&gt;select id from product where product_no = &#39;0002&#39;;&lt;/code&gt;，在二级索引中即可得到主键值，因此直接返回主键ID即可而无需查询主键索引，这个过程叫覆盖查找。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;索引下推&lt;/strong&gt;：MySQL 5.6 引入的索引下推优化，可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，该优化过程在引擎层进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span id=&#34;union_idx&#34;&gt;联合索引&lt;/span&gt;&lt;/strong&gt;：联合索引树形结构如下（该图建立了&lt;code&gt;&amp;lt;id,name&amp;gt;&lt;/code&gt;的二级联合索引，叶子结点为双向链表）：
&lt;img src=&#34;https://hifing.github.io/assets/img/%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95.webp&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;联合索引树结构&#34;
	
	
&gt;
并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询，比如字段需要&lt;strong&gt;范围查找&lt;/strong&gt;时，则该范围查找字段后的字段无法使用联合索引，因为在这个范围中，后面的字段是无序的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;TIP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是&lt;code&gt;select * from t_table where a &amp;gt;= 1 and b = 2;&lt;/code&gt;这个语句查询过程中，虽然在符合&lt;code&gt;a &amp;gt;= 1&lt;/code&gt;条件的二级索引记录的范围里，&lt;code&gt;b&lt;/code&gt;字段的值是无序的，但是对于符合&lt;code&gt;a = 1&lt;/code&gt;的二级索引记录的范围里，&lt;code&gt;b&lt;/code&gt;字段的值是有序的。
于是，在确定需要扫描的二级索引的范围时，当二级索引记录的&lt;code&gt;a&lt;/code&gt;字段值为1时，可以通过&lt;code&gt;b = 2&lt;/code&gt;条件减少需要扫描的二级索引记录范围（&lt;code&gt;b&lt;/code&gt;字段可以利用联合索引进行索引查询的意思）。
也就是说，从符合&lt;code&gt;a = 1 and b = 2&lt;/code&gt;条件的第一条记录开始扫描，而不需要从第一个&lt;code&gt;a&lt;/code&gt;字段值为1的记录开始扫描。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;mysql的b树&#34;&gt;MySQL的B+树&lt;/h2&gt;
&lt;h3 id=&#34;为什么选择b树&#34;&gt;为什么选择B+树？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;B+Tree 是一种多叉树，&lt;strong&gt;叶子节点才存放数据，非叶子节点只存放索引&lt;/strong&gt;，而且每个节点里的数据是按主键顺序存放的，索引叶子结点结构为一条双向链表。&lt;/li&gt;
&lt;li&gt;数据库的索引和数据都是存储在硬盘的。&lt;strong&gt;B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点&lt;/strong&gt;。另外，B+Tree 叶子节点采用的是&lt;strong&gt;双向链表&lt;/strong&gt;连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。&lt;/li&gt;
&lt;li&gt;在实际应用中，B+树的度大于100，保证千万量级数据下B+树的高度为3-4，减少磁盘I/O次数。&lt;/li&gt;
&lt;li&gt;Hash在等值查询时非常高效，但是Hash表不适合做范围查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mysql-b树数据页&#34;&gt;MySQL B+树数据页&lt;/h3&gt;
&lt;div align=&#34;center&#34;&gt;&lt;img width=300px src=../../assets/img/数据页.webp /&gt;&lt;/div&gt;
数据页中的记录按照主键顺序组成单向链表，数据页中有一个页目录，起到记录的索引作用：
&lt;div align=&#34;center&#34;&gt;&lt;img width=400px src=../../assets/img/页目录.webp /&gt;&lt;/div&gt;
通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录。
&lt;h2 id=&#34;索引失效与索引优化&#34;&gt;索引失效与索引优化&lt;/h2&gt;
&lt;h3 id=&#34;索引失效&#34;&gt;索引失效&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;联合索引失效：如&lt;a href=&#34;#union_idx&#34;&gt;前文&lt;/a&gt;所示，使用联合索引时，存在&lt;strong&gt;最左匹配&lt;/strong&gt;原则，即若不设定&lt;code&gt;id&lt;/code&gt;的查询条件直接根据&lt;code&gt;name&lt;/code&gt;的条件查询，则该联合索引失效。值得注意的是，由于&lt;strong&gt;优化器&lt;/strong&gt;对SQL语句的优化措施，打乱&lt;code&gt;where&lt;/code&gt;中的顺序不影响查询方案的确定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;左或者左右模糊匹配&lt;/strong&gt;：&lt;code&gt;like %xx&lt;/code&gt; 或者 &lt;code&gt;like %xx%&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;对索引列做了&lt;strong&gt;计算&lt;/strong&gt;、函数、类型转换操作。&lt;/li&gt;
&lt;li&gt;在 WHERE 子句中，如果在 &lt;code&gt;OR&lt;/code&gt; 前的条件列是索引列，而在 &lt;code&gt;OR&lt;/code&gt; 后的条件列不是索引列，那么索引会失效。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;TIP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;索引效率排行（低到高）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All（全表扫描）；&lt;/li&gt;
&lt;li&gt;index（全索引扫描）；&lt;/li&gt;
&lt;li&gt;range（索引范围扫描）；&lt;/li&gt;
&lt;li&gt;ref（非唯一索引扫描）；&lt;/li&gt;
&lt;li&gt;eq_ref（唯一索引扫描）；&lt;/li&gt;
&lt;li&gt;const（结果只有一条的主键或唯一索引扫描）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;索引优化&#34;&gt;索引优化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;前缀优化：使用某个字段中字符串的前几个字符建立索引，既减小索引字段大小，又有效提高索引的查询速度。&lt;/li&gt;
&lt;li&gt;覆盖索引优化：当不需要查询出所有字段时，可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。&lt;/li&gt;
&lt;li&gt;主键自增：主键自增时新增记录是追加操作，能避免&lt;strong&gt;页分裂&lt;/strong&gt;的情况。页分裂会造成大量的存储碎片，导致查询效率不高。&lt;/li&gt;
&lt;li&gt;NOT NULL：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化。NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题。&lt;/li&gt;
&lt;li&gt;避免索引失效&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;什么时候用索引&#34;&gt;什么时候用索引&lt;/h2&gt;
&lt;p&gt;使用索引的场景：字段唯一性、经常where、group by、order by&lt;/p&gt;
&lt;p&gt;不需要使用索引的场景：字段存在大量重复数据（比如性别）、经常更新的字段&lt;/p&gt;
&lt;h2 id=&#34;拓展&#34;&gt;拓展&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MyISAM 和 InnoDB 中 B+ 树的差异：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“&lt;strong&gt;非聚簇索引&lt;/strong&gt;”。
InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“&lt;strong&gt;聚簇索引&lt;/strong&gt;（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脑筋急转弯：使用左模糊匹配（like &amp;ldquo;%xx&amp;rdquo;）并不一定会走全表扫描，关键还是看数据表中的字段。如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;count性能对比：
&lt;code&gt;count()&lt;/code&gt;是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是&lt;strong&gt;统计符合查询条件的记录&lt;/strong&gt;中，函数指定的参数&lt;strong&gt;不为 NULL&lt;/strong&gt;的记录有多少个。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;count(*)=count(1)&amp;gt;count(主键字段)&amp;gt;count(字段)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用&lt;code&gt;key_len&lt;/code&gt;最小的二级索引进行扫描。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大表count()操作时费时间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用近似值（如explain命令）&lt;/li&gt;
&lt;li&gt;新建额外表保存计数信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
