[{"content":"","date":"2023-04-21T14:47:17+08:00","permalink":"https://hifing.github.io/p/mysql%E4%BA%8B%E5%8A%A1/","title":"MySQL事务"},{"content":"MySQL结构 MySQL的一个设计思想：如果内存够用，就要多利用内存，尽量减少磁盘访问。\n一条select语句的执行流程 连接器负责与客户端进行TCP三次握手，校验用户名密码，读取用户身份与操作权限。\n此处的查询缓存是在Server层执行的，并不是存储引擎中的buffer pool。当数据表频繁更新，或者查询的数据非常庞大时，缓存命中率可能不会很高，考虑到Server层的缓存实用性不大，因此，从MySQL 8.0 开始，执行一条 SQL 查询语句，不会再在Server层中执行查询缓存的步骤了。\n在执行SQL语句前，先由解析器对SQL语句进行解析，该步骤分为词法分析和语法分析。其中，在词法分析时，MySQL根据SQL关键词构建SQL语法树；语法分析时，解析器会根据语法规则，判断输入的 SQL 语句是否满足 MySQL 语法，比如，把from写成form。\n在执行SQL语句时，会分为以下三个阶段：\n预处理：检查SQL中的表或者字段是否存在，将*扩展为表上所有的列。\n优化：优化器负责将SQL查询语句的执行方案确定下来。\n执行：（以select * from product where id = 1;为例）\n优化的访问类型为const（常量查询，此外还有all、range等），首次查询调用read_first_record函数指针指向的函数，让存储引擎读取符合条件的第一条记录；\n通过主键索引的B+树定位第一条记录；\n执行器（Server层）判断记录是否符合查询条件；\n查询过程为while循环，调用read_record函数指针指向的函数，因为是const访问类型，该指针指向-1，查询结束。\n索引下推对执行阶段的优化 使用索引下推（MySQL 5.6 以后）能减少二级索引在查询时的回表操作，提高效率，它将Server层部分负责的任务交给引擎层去处理。\n以select * from t_user where age \u0026gt; 20 and reward = 100000;为例（已建立age和reward的联合索引）：\n联合索引遇到范围查找会停止匹配，此SQL仅age能使用联合索引，当开启索引下推时，根据二级索引查询获取到的一条记录，引擎层直接判断reward是否符合条件，若不符合，则直接舍弃。（若不开启，则需要先进行回表操作，把完整数据反馈至Server层，由Server层判断）\nInnoDB和MyISAM的不同 MyISAM 只有表级锁，而 InnoDB 支持行级锁和表级锁，默认为行级锁。\nMyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交和回滚事务的能力。并且，InnoDB 默认使用的可重读隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。\nMyISAM 不支持外键，而 InnoDB 支持。\n使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 redo log 。MyISAM不支持。\n虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。\nInnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。\n","date":"2023-04-21T14:47:17+08:00","permalink":"https://hifing.github.io/p/mysql%E5%9F%BA%E7%A1%80/","title":"MySQL基础"},{"content":"","date":"2023-04-21T14:47:17+08:00","permalink":"https://hifing.github.io/p/mysql%E6%97%A5%E5%BF%97/","title":"MySQL日志"},{"content":"MySQL索引 概念 几种数据结构对比：平衡二叉树、B树、B+树、B*树介绍 与 演示链接\n回表：查询二级索引时将会得到主键值，根据主键值查询主键索引才能得到整行数据，这个过程叫做回表，即需要查询这两个B+树才能得到数据本身。\n覆盖查找：如SQL语句select id from product where product_no = '0002';，在二级索引中即可得到主键值，因此直接返回主键ID即可而无需查询主键索引，这个过程叫覆盖查找。\n索引下推：MySQL 5.6 引入的索引下推优化，可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，该优化过程在引擎层进行。\n联合索引：联合索引树形结构如下（该图建立了\u0026lt;id,name\u0026gt;的二级联合索引，叶子结点为双向链表）： 并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询，比如字段需要范围查找时，则该范围查找字段后的字段无法使用联合索引，因为在这个范围中，后面的字段是无序的。\nTIP\n但是select * from t_table where a \u0026gt;= 1 and b = 2;这个语句查询过程中，虽然在符合a \u0026gt;= 1条件的二级索引记录的范围里，b字段的值是无序的，但是对于符合a = 1的二级索引记录的范围里，b字段的值是有序的。 于是，在确定需要扫描的二级索引的范围时，当二级索引记录的a字段值为1时，可以通过b = 2条件减少需要扫描的二级索引记录范围（b字段可以利用联合索引进行索引查询的意思）。 也就是说，从符合a = 1 and b = 2条件的第一条记录开始扫描，而不需要从第一个a字段值为1的记录开始扫描。\nMySQL的B+树 为什么选择B+树？ B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的，索引叶子结点结构为一条双向链表。 数据库的索引和数据都是存储在硬盘的。B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。另外，B+Tree 叶子节点采用的是双向链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。 在实际应用中，B+树的度大于100，保证千万量级数据下B+树的高度为3-4，减少磁盘I/O次数。 Hash在等值查询时非常高效，但是Hash表不适合做范围查询。 MySQL B+树数据页 数据页中的记录按照主键顺序组成单向链表，数据页中有一个页目录，起到记录的索引作用： 通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录。 索引失效与索引优化 索引失效 联合索引失效：如前文所示，使用联合索引时，存在最左匹配原则，即若不设定id的查询条件直接根据name的条件查询，则该联合索引失效。值得注意的是，由于优化器对SQL语句的优化措施，打乱where中的顺序不影响查询方案的确定。 左或者左右模糊匹配：like %xx 或者 like %xx%。 对索引列做了计算、函数、类型转换操作。 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。 TIP\n索引效率排行（低到高）：\nAll（全表扫描）； index（全索引扫描）； range（索引范围扫描）； ref（非唯一索引扫描）； eq_ref（唯一索引扫描）； const（结果只有一条的主键或唯一索引扫描）。 索引优化 前缀优化：使用某个字段中字符串的前几个字符建立索引，既减小索引字段大小，又有效提高索引的查询速度。 覆盖索引优化：当不需要查询出所有字段时，可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。 主键自增：主键自增时新增记录是追加操作，能避免页分裂的情况。页分裂会造成大量的存储碎片，导致查询效率不高。 NOT NULL：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化。NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题。 避免索引失效 什么时候用索引 使用索引的场景：字段唯一性、经常where、group by、order by\n不需要使用索引的场景：字段存在大量重复数据（比如性别）、经常更新的字段\n拓展 MyISAM 和 InnoDB 中 B+ 树的差异：\nMyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。 InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。\nMySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。\n脑筋急转弯：使用左模糊匹配（like \u0026ldquo;%xx\u0026rdquo;）并不一定会走全表扫描，关键还是看数据表中的字段。如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。\ncount性能对比： count()是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是统计符合查询条件的记录中，函数指定的参数不为 NULL的记录有多少个。\ncount(*)=count(1)\u0026gt;count(主键字段)\u0026gt;count(字段)\nMySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用key_len最小的二级索引进行扫描。\n大表count()操作时费时间：\n使用近似值（如explain命令） 新建额外表保存计数信息 ","date":"2023-04-21T14:47:17+08:00","permalink":"https://hifing.github.io/p/mysql%E7%B4%A2%E5%BC%95/","title":"MySQL索引"},{"content":"","date":"2023-04-21T14:47:17+08:00","permalink":"https://hifing.github.io/p/mysql%E9%94%81/","title":"MySQL锁"},{"content":"计数 投票 多数元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int majorityElement(int[] nums) { int now = nums[0]; int count = 1; for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] == now) count++; else { if (count \u0026gt; 0) count--; else { count = 1; now = nums[i]; } } } return now; } } 使用摩尔投票法将复杂度将为O（n），也可以用分治的思想，左右选出的候选人再在整个区间内进行比较，数目多的取胜，复杂度为O（nlogn）。\n","date":"2022-08-19T01:04:20+08:00","permalink":"https://hifing.github.io/p/%E8%AE%A1%E6%95%B0/","title":"计数"},{"content":"","date":"2022-08-18T22:48:50+08:00","permalink":"https://hifing.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","title":"分布式文件系统"},{"content":"哈希 HashSet 最长连续序列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int longestConsecutive(int[] nums) { Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int ele : nums) set.add(ele); int res = 0; for (int ele : nums) { if (!set.contains(ele - 1)) { int count = 1; int tmp = ele + 1; while (set.contains(tmp)) { count++; tmp++; } res = Math.max(res, count); } } return res; } } 将元素都收到Set中，从连续序列的最小元素开始搜索到最大处，如果还有连续的更小的，则放弃此次循环\nHashMap 和为 K 的子数组 将前缀记录在map里头，往后边扫描边查缺的数字。\n","date":"2022-08-18T00:21:42+08:00","permalink":"https://hifing.github.io/p/%E5%93%88%E5%B8%8C/","title":"哈希"},{"content":"贪心 相关题目：下一个排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public void reverse(int[] nums, int l, int r) { int tmp; while (l \u0026lt; r) { tmp = nums[l]; nums[l] = nums[r]; nums[r] = tmp; l++; r--; } } public void nextPermutation(int[] nums) { int i = nums.length - 1; for (; i \u0026gt; 0; i--) { if (nums[i] \u0026gt; nums[i - 1]) break; } if (i == 0) reverse(nums, 0, nums.length - 1); else { for (int j = nums.length - 1; j \u0026gt; i - 1; j--) { if (nums[j] \u0026gt; nums[i - 1]) { int tmp = nums[j]; nums[j] = nums[i - 1]; nums[i - 1] = tmp; reverse(nums, i, nums.length - 1); return; } } } } } 从尾到头找到一个极大值点，在极值点右侧这个递减序列中从右往左找到极值点左侧元素的位置，使得左侧元素刚好比这个位置的元素大，替换后，翻转右侧序列。\n","date":"2022-08-17T22:13:57+08:00","permalink":"https://hifing.github.io/p/%E8%B4%AA%E5%BF%83/","title":"贪心"},{"content":"SpringCloud Gateway SpringCloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架。\nGateway的使用：SpringCloud gateway\nZuul的IO模型 Springcloud中所集成的Zuul版本，采用的是Tomcat容器，使用的是传统的Servlet IO处理模型，会为每个请求分配一个线程来处理，无法应付高并发场景下的需求，所以Springcloud Zuul 是基于servlet之上的一个阻塞式处理模型。\nWebflux 服务器 Reactive Stream 是一套反应式编程 标准 和 规范；它由发布者、订阅者、订阅、处理器组成。 Reactor 是基于 Reactive Streams 一套 反应式编程框架；Mono实现了发布者功能，返回0-1个元素，Flux返回N个元素。 WebFlux 以 Reactor 为基础，实现 Web 领域的 反应式编程框架。在 WebFlux 接口中，请求不会被阻塞，所以服务端的接口耗时为 0。 注册中心 服务注册中心本质上是为了解耦服务提供者和服务消费者。对于任何一个微服务，原则上都应存在或者支持多个提供者，这是由微服务的分布式属性决定的。更进一步，为了支持弹性扩缩容特性，一个微服务的提供者的数量和分布往往是动态变化的，也是无法预先确定的。因此，原本在单体应用阶段常用的静态LB机制就不再适用了，需要引入额外的组件来管理微服务提供者的注册与发现，而这个组件就是服务注册中心。\n需要考虑的问题：\n测活：服务注册之后，如何对服务进行测活以保证服务的可用性？ 负载均衡：当存在多个服务提供者时，如何均衡各个提供者的负载？ 集成：在服务提供端或者调用端，如何集成注册中心？ 运行时依赖：引入注册中心之后，对应用的运行时环境有何影响？ 可用性：如何保证注册中心本身的可用性，特别是消除单点故障？ CAP理论 一致性(Consistency) (所有节点在同一时间具有相同的数据) 可用性(Availability) (保证每个请求不管成功或者失败都有响应) 分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作) Nacos Nacos内部接收到注册的请求时，不会立即写数据，而是将服务注册的任务放入一个阻塞队列就立即响应给客户端。然后利用线程池读取阻塞队列中的任务，异步来完成实例更新，从而提高并发写能力。 Nacos在更新实例列表时，会采用CopyOnWrite技术，首先将旧的实例列表拷贝一份，然后更新拷贝的实例列表，再用更新后的实例列表来覆盖旧的实例列表。 通过Ribbon实现负载均衡。（随机、轮询、加权、少并发连接优先、重试、区域敏感、可用性敏感） vs Eureka： Nacos的实例有永久和临时实例之分；而Eureka只支持临时实例 Nacos对临时实例采用心跳模式检测，对永久实例采用主动请求来检测；Eureka只支持心跳模式 Nacos支持定时拉取和订阅推送两种模式；Eureka只支持定时拉取模式 配置中心： 一般会存：可能会经常变化的配置信息，例如连接池，日志，线程池，限流熔断规则 我们的服务一般会先从内存中读取配置信息，同时我们的微服务还可以定时向nacos配置中心发请求拉取更新的配置信息 限流 限流算法 固定窗口限流\n首先维护一个计数器，将单位时间段当做一个窗口，计数器记录这个窗口接收请求的次数。\n当次数少于限流阀值，就允许访问，并且计数器+1 当次数大于限流阀值，就拒绝访问。 当前的时间窗口过去之后，计数器清零。 滑动窗口限流\n滑动窗口限流解决固定窗口临界值的问题。它将单位时间周期分为n个小周期，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。\n漏桶算法\n往漏桶中以任意速率流入水，以固定的速率流出水。当水超过桶的容量时，会被溢出，也就是被丢弃。因为桶容量是不变的，保证了整体的速率。\n在正常流量的时候，系统按照固定的速率处理请求，是我们想要的。但是面对突发流量的时候，漏桶算法还是循规蹈矩地处理请求，这就不是我们想看到的啦。流量变突发时，我们肯定希望系统尽量快点处理请求，提升用户体验嘛。\n令牌桶算法\n有一个令牌管理员，根据限流大小，定速往令牌桶里放令牌。如果令牌数量满了，超过令牌桶容量的限制，那就丢弃。系统在接受到一个用户请求时，都会先去令牌桶要一个令牌。如果拿到令牌，那么就处理这个请求的业务逻辑；如果拿不到令牌，就直接拒绝这个请求。\nGateway则采用了基于Redis实现的令牌桶算法，而Sentinel内部却比较复杂：\n默认限流模式是基于滑动时间窗口算法 排队等待的限流模式则基于漏桶算法 而热点参数限流则是基于令牌桶算法 Sentinel vs Hystrix：\nHystix默认是基于线程池实现的线程隔离，每一个被隔离的业务都要创建一个独立的线程池，线程过多会带来额外的CPU开销，性能一般，但是隔离性更强。\nSentinel是基于信号量（计数器）实现的线程隔离，不用创建线程池，性能较好，但是隔离性一般。\n流量控制：\n直接拒绝 冷启动 匀速器 RPC Feign Dubbo 一致性哈希算法 一致性Hash原理与实现 - 简书 (jianshu.com)\n链路追踪 实战 使用nacos、openfegin、gateway、链路追踪管理微服务_你看星星很亮的博客-CSDN博客\n","date":"2022-08-16T16:35:51+08:00","permalink":"https://hifing.github.io/p/springcloud/","title":"SpringCloud"},{"content":"回溯 全排列 II 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res; public void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } public void recur(int[] nums, int index) { if (index == nums.length) { List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (int ele : nums) list.add(ele); res.add(list); return; } Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int i = index; i \u0026lt; nums.length; i++) { if (!set.contains(nums[i])) { set.add(nums[i]); swap(nums, index, i); recur(nums, index + 1); swap(nums, index, i); } } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { res = new ArrayList\u0026lt;\u0026gt;(); recur(nums, 0); return res; } } 使用Set防止重复元素的操作。\n缺失的第一个正数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int firstMissingPositive(int[] nums) { int tmp = 0; for (int i = 0; i \u0026lt; nums.length;) { if (nums[i] == i + 1 || nums[i] \u0026gt; nums.length || nums[i] \u0026lt; 1) { i++; continue; } tmp = nums[i]; if (nums[i] == nums[nums[i] - 1]) { i++; continue; } nums[i] = nums[nums[i] - 1]; nums[tmp - 1] = tmp; } for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] != i + 1) return i + 1; } return nums.length + 1; } } 运用置换的方法，可以实现O(n)的时间复杂度。 因为当数组每一个位置都正确地放置了该放置的数之后，最小的正数会是数组之外的数，若是数组还有成员没有被正确放置，那么他可能就是答案。\n要注意可能会有无限循环的情况，比如出现重复的数，这个时候只要跳出去本次遍历直接处理下一个就好了。\n","date":"2022-08-16T11:26:43+08:00","permalink":"https://hifing.github.io/p/%E5%9B%9E%E6%BA%AF/","title":"回溯"},{"content":"搜索 二分查找 搜索旋转排序数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int recur(int[] nums, int begin, int end, int target) { if (begin == end) { if (target == nums[begin]) return begin; else return -1; } int mid = (begin + end) \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= nums[begin]) if (nums[begin] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt;= nums[mid]) return Arrays.binarySearch(nums, begin, end + 1, target); else return recur(nums, mid + 1, end, target); else if (nums[end] \u0026gt;= target \u0026amp;\u0026amp; target \u0026gt;= nums[mid]) return Arrays.binarySearch(nums, begin, end + 1, target); else return recur(nums, begin, mid - 1, target); } public int search(int[] nums, int target) { int res = recur(nums, 0, nums.length - 1, target); return res \u0026gt;= 0 ? res : -1; } } 将旋转数组分为两段，一段必然升序，若在升序段中找不到，则在另一段中再分再找。\n最长递增子序列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // O(n^2)的方法为dp，下面用二分优化达到O(nlogn)级别 class Solution { public int lengthOfLIS(int[] nums) { int n = nums.length; int[] record = new int[n]; int index = 0; for (int ele : nums) { int l = 0, r = index; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (ele \u0026gt; record[mid]) l = mid + 1; else r = mid; } record[l] = ele; if (l == index) index++; } return index; } } record的长度就是结果，在过程中更新record中的元素，使之越来越小以满足后面的元素插入数组来拓宽长度，这不影响之前获得的临时最长递增子序列长度的结果。\n寻找两个正序数组的中位数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int[] less; int[] more; if (nums1.length \u0026lt; nums2.length) { less = nums1; more = nums2; } else { less = nums2; more = nums1; } int n1 = less.length; int n2 = more.length; int left = 0, right = less.length; // 右边会持有单独的中位数 while (left \u0026lt; right) { int mid = (left + right) / 2; int secondIndex = (n1 + n2 - 2 * mid) / 2; if (mid - 1 \u0026gt;= 0 \u0026amp;\u0026amp; secondIndex \u0026lt; n2 \u0026amp;\u0026amp; less[mid - 1] \u0026gt; more[secondIndex]) right = mid - 1; else if (secondIndex - 1 \u0026gt;= 0 \u0026amp;\u0026amp; mid \u0026lt; n1 \u0026amp;\u0026amp; less[mid] \u0026lt; more[secondIndex - 1]) left = mid + 1; else break; } double res = 0; int one = (left + right) / 2; int two = (n1 + n2 - 2 * one) / 2; if ((n1 + n2) % 2 == 1) { // 奇数取右边 res = Math.min((one == n1 ? Integer.MAX_VALUE : less[one]), (two == n2 ? Integer.MAX_VALUE : more[two])); } else { double tmpLeft = Math.max((one == 0 ? Integer.MIN_VALUE : less[one - 1]), (two == 0 ? Integer.MIN_VALUE : more[two - 1])); double tmpRight = Math.min((one == n1 ? Integer.MAX_VALUE : less[one]), (two == n2 ? Integer.MAX_VALUE : more[two])); res = (tmpLeft + tmpRight) / 2; } return res; } } 找到两个数组的index，使得这两个index左侧的数都小于右侧的数。最终结果根据奇偶性分开处理。\n在排序数组中查找元素的第一个和最后一个位置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int[] searchRange(int[] nums, int target) { if (nums.length == 0) return new int[]{ -1, -1 }; int l = 0, r = nums.length - 1; while (l \u0026lt; r) { // 位运算优先级低，要用括号包起来 int mid = l + ((r - l) \u0026gt;\u0026gt; 1); if (nums[mid] \u0026gt;= target) r = mid; else l = mid + 1; } int low = -1; if (nums[l] == target) low = l; l = 0; r = nums.length - 1; while (l \u0026lt; r) { // 补一个1，让mid倾向于右边的元素 int mid = l + ((r - l + 1) \u0026gt;\u0026gt; 1); if (nums[mid] \u0026gt; target) r = mid - 1; else l = mid; } int high = -1; if (nums[l] == target) high = l; return new int[] { low, high }; } } 并查集 最大人工岛 先dfs把独立块的大小都计算出来存下来，再计算翻转每个0的时候能获得的联合块的大小。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // 一种省事一些的并查集方法 // 还没有编写反转0之后的逻辑 public class Main { int[] dr = new int[] { -1, 0, 1, 0 }; int[] dc = new int[] { 0, -1, 0, 1 }; int[][] grid; boolean[][] chk; int[] father; int m; int n; public int maxAreaOfIsland(int[][] grid) { this.grid = grid; m = grid.length; n = grid[0].length; chk = new boolean[m][n]; father = new int[m * n]; Arrays.fill(father, -1); int result = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == 0 || chk[i][j]) continue; int myIndex = i * n + j; // 携带father下标传下去，dfs过程中，扫到的下标都会变成这个下标 int res = dfs(i, j, myIndex); father[myIndex] = -1 * res; result = Math.max(result, res); } } return result; } public int dfs(int i, int j, int index) { if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n || chk[i][j] || grid[i][j] == 0) return 0; int res = 1; int myIndex = i * n + j; father[myIndex] = index; chk[i][j] = true; for (int k = 0; k \u0026lt; 4; k++) { res += dfs(i + dr[k], j + dc[k], index); } return res; } 二维查找 搜索二维矩阵 II 1 2 3 4 5 6 7 8 9 10 11 12 13 public boolean searchMatrix(int[][] matrix, int target) { int x = matrix[0].length - 1; int y = 0; while (y \u0026lt; matrix.length \u0026amp;\u0026amp; x \u0026gt;= 0) { if (matrix[y][x] == target) return true; else if (matrix[y][x] \u0026gt; target) x--; else y++; } return false; } Z字形搜索，控制一个方向为增大，一个方向为减小，这样就不用考虑两个方向同为增大而进行分类讨论了。\n也可以逐行进行二分查找。\n","date":"2022-08-15T21:19:38+08:00","permalink":"https://hifing.github.io/p/%E6%90%9C%E7%B4%A2/","title":"搜索"},{"content":"链表 翻转链表 K 个一组翻转链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public ListNode reverseKGroup(ListNode head, int k) { if (k == 1 || head == null) return head; ListNode blank = new ListNode(); blank.next = head; int count = k; ListNode last = head; while (count \u0026gt; 0) { last = last.next; --count; if (last == null \u0026amp;\u0026amp; count \u0026gt; 0) return head; } ListNode prev = blank; ListNode now = head; ListNode next = now; while(now!=last){ next = now.next; now.next = prev; prev = now; now = next; } head.next = reverseKGroup(now, k); return prev; } 重排链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //使用Deque更方便，为追求极致的空间复杂度可以先找中点，再反转，再拼接 class Solution { public void reorderList(ListNode head) { Deque\u0026lt;ListNode\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); ListNode tmp = head.next; while (tmp != null) { deque.addLast(tmp); tmp = tmp.next; } boolean flag = true; tmp = head; while (!deque.isEmpty()) { tmp.next = (flag ? deque.pollLast() : deque.pollFirst()); tmp = tmp.next; flag = !flag; } tmp.next=null; } } 排序链表 1 2 3 //可以对链表一分为二进行归并排序，在操作的过程中可以断开两个链表的链接，这样处理更加方便 //也可以参考快速排序，用两个空节点收录比pivot大的节点串和比pivot小的节点串，再对这两个串处理，处理之后按照“小-\u0026gt;pivot-\u0026gt;大”这样的顺序组装返回 环形链表找环的入口 环形链表 II 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Solution { public ListNode detectCycle(ListNode head) { if(head == null) return null; ListNode slow = head; ListNode fast = head.next; ListNode empty = new ListNode(); empty.next = head; while (slow != fast \u0026amp;\u0026amp; fast != null) { slow = slow.next; fast = fast.next; if (fast == null) break; fast = fast.next; } if (fast == null) return null; ListNode tmp = empty; while (tmp != fast) { tmp = tmp.next; fast = fast.next; } return tmp; } } LRU缓存机制 使用双向链表和哈希表的方式模拟LRU\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class Node { Node next; Node prev; int value; int key; } class LRUCache { int capacity; Node head; Node tail; Map\u0026lt;Integer, Node\u0026gt; map; public LRUCache(int capacity) { this.capacity = capacity; head = new Node(); tail = new Node(); head.next = tail; tail.prev = head; map = new HashMap\u0026lt;\u0026gt;(); } // get附带更新最新节点功能 public int get(int key) { if (map.containsKey(key)) { Node target = map.get(key); Node prev = target.prev; Node next = target.next; prev.next = next; next.prev = prev; Node headNext = head.next; head.next = target; target.prev = head; headNext.prev = target; target.next = headNext; return target.value; } else return -1; } public void put(int key, int value) { if (capacity \u0026lt;= 0) return; if (map.containsKey(key)) { Node n = map.get(key); n.value = value; } else { Node tmp = new Node(); tmp.value = value; tmp.key = key; if (capacity == map.size()) { Node last = tail.prev; map.remove(last.key); last.prev.next = last.next; last.next.prev = last.prev; } Node last = tail.prev; last.next = tmp; tmp.prev = last; tmp.next = tail; tail.prev = tmp; map.put(key, tmp); } // 更新时调用一下get即可 get(key); } } ","date":"2022-08-15T10:46:49+08:00","permalink":"https://hifing.github.io/p/%E9%93%BE%E8%A1%A8/","title":"链表"},{"content":"","date":"2022-08-15T01:13:46+08:00","permalink":"https://hifing.github.io/p/%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"字符串"},{"content":"排序 快速排序 模板题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { private void swap(int[] nums, int a, int b) { int tmp = nums[a]; nums[a] = nums[b]; nums[b] = tmp; } private void fastSort(int[] nums, int l, int r) { if (l \u0026gt;= r) return; // 也可以直接认定pivot为左端点 int start = l, end = r; swap(nums, start, (start + end) / 2); // 指针重合时退出 while (start \u0026lt; end) { // 先动右指针，避免指针重复时左指针指向超过pivot的数字 while (start \u0026lt; end \u0026amp;\u0026amp; nums[end] \u0026gt;= nums[l]) end--; while (start \u0026lt; end \u0026amp;\u0026amp; nums[start] \u0026lt;= nums[l]) start++; swap(nums, start, end); } // 交换左指针和pivot的位置 swap(nums, l, start); fastSort(nums, l, start - 1); fastSort(nums, start + 1, r); } public int[] sortArray(int[] nums) { fastSort(nums, 0, nums.length - 1); return nums; } } 出现频率最高的 k 个数字(TOPK) topK(无序：小顶堆、单分支快排)\n快排变体（单分支快排），当然，本题用堆来做思路非常清晰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); } List\u0026lt;int[]\u0026gt; values = new ArrayList\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : map.entrySet()) { int num = entry.getKey(), count = entry.getValue(); values.add(new int[] { num, count }); } findK(k, values); int[] ret = new int[k]; for (int i = 0; i \u0026lt; k; i++) ret[i] = values.get(i)[0]; return ret; } public void findK(int k, List\u0026lt;int[]\u0026gt; values) { int l = 0; int n = values.size(); int r = n - 1; while (l \u0026lt; r) { int index = qsort(l, r, values); if (index == k - 1) return; else if (index \u0026lt; k - 1) l = index + 1; else r = index - 1; } } public int qsort(int l, int r, List\u0026lt;int[]\u0026gt; values) { int pivot = values.get(l)[1]; int start = l; while (l \u0026lt; r) { while (l \u0026lt; r \u0026amp;\u0026amp; values.get(r)[1] \u0026lt;= pivot) r--; while (l \u0026lt; r \u0026amp;\u0026amp; values.get(l)[1] \u0026gt;= pivot) l++; if (l \u0026lt; r) Collections.swap(values, l, r); } Collections.swap(values, start, r); return r; } 堆排序 手撕堆排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public void dropDown(int[] nums, int index, int limit) { if (index * 2 + 1 \u0026gt;= limit) return; boolean flag = false; int change = index; if (nums[index] \u0026lt; nums[index * 2 + 1]) { flag = true; change = index * 2 + 1; } if (index * 2 + 2 \u0026lt; limit \u0026amp;\u0026amp; nums[change] \u0026lt; nums[index * 2 + 2]) { flag = true; change = index * 2 + 2; } if (flag) { int tmp = nums[change]; nums[change] = nums[index]; nums[index] = tmp; dropDown(nums, change, limit); } } public int[] sortArray(int[] nums) { int start = (nums.length - 2) / 2; for (; start \u0026gt;= 0; start--) { dropDown(nums, start, nums.length); } for (int i = nums.length - 1; i \u0026gt; 0; i--) { int tmp = nums[i]; nums[i] = nums[0]; nums[0] = tmp; dropDown(nums, 0, i); } return nums; } } ","date":"2022-07-04T16:46:07+08:00","permalink":"https://hifing.github.io/p/%E6%8E%92%E5%BA%8F/","title":"排序"},{"content":"栈与队列 单调栈 直方图最大矩形面积 优化版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int largestRectangleArea(int[] heights) { int res = 0; int n = heights.length; int[] left = new int[n]; int[] right = new int[n]; Arrays.fill(right, n); Deque\u0026lt;Integer\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { // 记录右边界 while (!deque.isEmpty() \u0026amp;\u0026amp; heights[deque.peekLast()] \u0026gt;= heights[i]) { int top = deque.removeLast(); right[top] = i; } // 因为是单调递增的，所以左边界也确定了 left[i] = deque.isEmpty() ? -1 : deque.peekLast(); deque.addLast(i); } for (int i = 0; i \u0026lt; n; i++) { res = Math.max(res, heights[i] * (right[i] - left[i] - 1)); } return res; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public int valueOfArray(int[] heights, int index) { if (index \u0026lt; 0) return -1; if (index \u0026gt;= heights.length) return 0; else return heights[index]; } public int largestRectangleArea(int[] heights) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); int res = 0; stack.add(-1); int n = heights.length; for (int i = 0; i \u0026lt;= n; i++) { if (valueOfArray(heights, i) \u0026gt; valueOfArray(heights, stack.peek())) stack.push(i); else { while (valueOfArray(heights, i) \u0026lt;= valueOfArray(heights, stack.peek())) { int top = valueOfArray(heights, stack.pop()); int width = i - stack.peek() - 1; res = Math.max(res, top * width); } stack.push(i); } } return res; } } 接雨水 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //单调栈做法 public int trap(int[] height) { int res = 0; Stack\u0026lt;Integer\u0026gt; stk = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; height.length; i++) { while (!stk.isEmpty()) { if (height[i] \u0026lt; height[stk.peek()]) break; int index = stk.pop(); if (stk.isEmpty()) break; int minHeight = Math.min(height[i], height[stk.peek()]); res += (minHeight - height[index]) * (i - stk.peek() - 1); } stk.add(i); } return res; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 //双指针做法 class Solution { public int trap(int[] height) { int res = 0; int left = 0, right = height.length - 1; int leftMax = height[left], rightMax = height[right]; while (left \u0026lt;= right) { while (leftMax \u0026lt;= rightMax \u0026amp;\u0026amp; left \u0026lt;= right) { if (height[left] \u0026gt; leftMax) { leftMax = height[left]; } else { res += (leftMax - height[left]); } left++; } while (leftMax \u0026gt; rightMax \u0026amp;\u0026amp; left \u0026lt;= right) { if (height[right] \u0026gt; rightMax) { rightMax = height[right]; } else { res += (rightMax - height[right]); } right--; } } return res; } } //稍微优雅一些的写法 public int trap(int[] height) { int res = 0; int left = 0, leftMax = height[left], right = height.length - 1, rightMax = height[right]; while (left \u0026lt;= right) { leftMax = Math.max(leftMax, height[left]); rightMax = Math.max(rightMax, height[right]); if (leftMax \u0026gt; rightMax) res += rightMax - height[right--]; else res += leftMax - height[left++]; } return res; } 单调队列 滑动窗口最大值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int[] maxSlidingWindow(int[] nums, int k) { Deque\u0026lt;Integer\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); int i = 0; for (; i \u0026lt; k; i++) { while (!deque.isEmpty() \u0026amp;\u0026amp; deque.peekLast() \u0026lt; nums[i]) deque.pollLast(); deque.addLast(nums[i]); } res.add(deque.peekFirst()); for (; i \u0026lt; nums.length; i++) { if (deque.peekFirst() == nums[i - k]) deque.pollFirst(); while (!deque.isEmpty() \u0026amp;\u0026amp; deque.peekLast() \u0026lt; nums[i]) deque.pollLast(); deque.addLast(nums[i]); res.add(deque.peekFirst()); } int[] resArray = new int[res.size()]; for (int j = 0; j \u0026lt; res.size(); j++) { resArray[j] = res.get(j); } return resArray; } } 滑动窗口滑动的过程中势必要记录下新进来的元素，删除被挤出的元素，只不过在收入新进来的元素的时候先保持滑动窗口中的最大值不小于这个元素，这样一来小的元素就无需被队列记录下来了。等到这个元素出去的时候再比对队首元素与之是否相同，若相同则直接删掉就好了。遇到重复的值的时候也要记录下来，防止一个被弹出另一个不知道。\n栈 最长有效括号 让没有用的元素垫底作为界定标准，先弹栈再计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int longestValidParentheses(String s) { Stack\u0026lt;Integer\u0026gt; stk = new Stack\u0026lt;\u0026gt;(); stk.push(-1); int res = 0; for (int i = 0; i \u0026lt; s.length(); i++) { if (s.charAt(i) == \u0026#39;(\u0026#39;) { stk.push(i); } else { stk.pop(); if (!stk.isEmpty()) { res = Math.max(res, i - stk.peek()); } else { stk.push(i); } } } return res; } } 本题还可以使用DP来做，当遇到右括号的时候，记录下与之匹配的左括号的位置，倘若在这个过程中找到了之前的一个已经匹配完成的右括号，则顺着它继续往前面找，直到找到一个左括号，找不到左括号就记为0.\n还可以根据贪心来做，从左边开始扫描，记录下左括号数目和右括号数目，当两者相等时，记录下此时的长度，当右括号数目大一些时，清零。因为会遇到“（（）”这种情况使得算不出结果，因此需要从右往左再进行一次相对的扫描。\n","date":"2022-07-04T16:04:44+08:00","permalink":"https://hifing.github.io/p/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","title":"栈与队列"},{"content":"小妙招 枚举结果（20220820网易：a和b选其一去除掉一个数位使得他们能是某一方的倍数） count设为long类型 ","date":"2022-07-04T12:10:40+08:00","permalink":"https://hifing.github.io/p/%E5%B0%8F%E5%A6%99%E6%8B%9B/","title":"小妙招"},{"content":"树 序列化与反序列化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); StringBuilder sb = new StringBuilder(); queue.add(root); while (!queue.isEmpty()) { TreeNode tn = queue.remove(); if (tn == null) { sb.append(\u0026#34;*,\u0026#34;); } else { sb.append(tn.val + \u0026#34;,\u0026#34;); queue.add(tn.left); queue.add(tn.right); } } System.out.println(sb.toString()); return sb.toString(); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { if (data.length() == 0) return null; String[] strs = data.split(\u0026#34;,\u0026#34;); int n = strs.length; if (strs[0].equals(\u0026#34;*\u0026#34;)) return null; TreeNode head = new TreeNode(Integer.valueOf(strs[0])); Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(head); int index = 1; while (!queue.isEmpty() \u0026amp;\u0026amp; index \u0026lt; n) { TreeNode tn = queue.remove(); TreeNode left = (strs[index].equals(\u0026#34;*\u0026#34;) ? null : new TreeNode(Integer.valueOf(strs[index]))); index++; TreeNode right = (strs[index].equals(\u0026#34;*\u0026#34;) ? null : new TreeNode(Integer.valueOf(strs[index]))); index++; tn.left = left; tn.right = right; if (left != null) queue.add(left); if (right != null) queue.add(right); } return head; } } 树的搜索 LCA：二叉树的最近公共祖先 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null) return root; if (root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null \u0026amp;\u0026amp; right != null) return root; if (left != null) return left; if (right != null) return right; return null; } } 二叉树中的最大路径和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 final int minimum = -1000; int res = minimum; public int search(TreeNode root) { if (root == null) return minimum; int left = search(root.left); int right = search(root.right); int maximumCombine = Math.max(0, Math.max(left, right)) + root.val; res = Math.max(res, Math.max(maximumCombine, left + right + root.val)); return maximumCombine; } public int maxPathSum(TreeNode root) { search(root); return res; } 更新res的时候有多种情况。返回上层时要确保root在计算结果中，以便上层能够连接子树结果。\n验证二叉搜索树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean chk(TreeNode root, long min, long max) { if (root == null) return true; if (root.val \u0026gt;= max || root.val \u0026lt;= min) return false; return chk(root.left, min, root.val) \u0026amp;\u0026amp; chk(root.right, root.val, max); } public boolean isValidBST(TreeNode root) { if (root == null) return true; return chk(root, Long.MIN_VALUE, Long.MAX_VALUE); } } 递归的时候把上下界传下去。\n二叉树最大宽度 DFS思路：按照先序，记录每层次最左侧的节点的满二叉树中的下标到Map中，若是已经有了，则减去已有的作为一个tmpResult。\nBFS思路：按照层次遍历，入队时记录下满二叉树对应的下标，每一层最后一个元素和第一个元素下标做差。\n","date":"2022-07-04T12:10:40+08:00","permalink":"https://hifing.github.io/p/%E6%A0%91/","title":"树"},{"content":"动态规划 串 回文子字符串的个数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // dp[i][j]表示形如“......，A[i]，A[j]”的序列 public int lenLongestFibSubseq(int[] arr) { int n = arr.length; Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { map.putIfAbsent(arr[i], i); } int res = 0; Map\u0026lt;Integer, Integer\u0026gt; longest = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { int index = map.getOrDefault(arr[i] - arr[j], -1); if (index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; j) { int length = longest.getOrDefault(index * n + j, 2) + 1; longest.put(j * n + i, length); res = Math.max(res, length); } } } return res; } public int countSubstrings(String s) { int n = s.length(); char[] str = s.toCharArray(); int[][] dp = new int[n][n]; int res = n; for (int i = 0; i \u0026lt; n; i++) { dp[i][i] = 1; } for (int i = 0; i \u0026lt; n; i++) { for (int j = i - 1; j \u0026gt;= 0; j--) { if (str[i] == str[j]) { if (j == i - 1) { dp[j][i] = 1; res++; } else if (dp[j + 1][i - 1] == 1) { dp[j][i] = 1; res++; } } } } return res; } 关联题：最长回文子串 （也可使用中心扩展的方法获取，要分奇偶两种情况）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { char[] seq; private int findLength(int start, boolean flag) { int left = start - (flag ? 1 : 0); int right = start; int length = (left == right ? -1 : 0); while (left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; seq.length) { if (seq[left] == seq[right]) { length += 2; left--; right++; } else break; } return length; } public String longestPalindrome(String s) { seq = s.toCharArray(); int nowMax = 0; int index = 0; for (int i = 0; i \u0026lt; seq.length; i++) { int singled = findLength(i, true); int doubled = findLength(i, false); if (singled \u0026gt; nowMax) { index = i; nowMax = singled; } if (doubled \u0026gt; nowMax) { index = i; nowMax = doubled; } } return s.substring(index - (nowMax / 2), index - (nowMax / 2) + nowMax); } } 最长公共子序列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int longestCommonSubsequence(String text1, String text2) { char[] s1, s2; s1 = text1.toCharArray(); s2 = text2.toCharArray(); int[][] dp = new int[s1.length + 1][s2.length + 1]; for (int i = 1; i \u0026lt;= s1.length; i++) { for (int j = 1; j \u0026lt;= s2.length; j++) { dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]); dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + (s1[i - 1] == s2[j - 1] ? 1 : 0)); } } return dp[s1.length][s2.length]; } } 处理i、j处的时候，分三种情况讨论，（i，j-1），（i-1，j），（i-1，j-1）\n矩阵 矩阵中的距离 1 2 输入：mat = [[0,0,0],[0,1,0],[1,1,1]] 输出：[[0,0,0],[0,1,0],[1,2,1]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public int[][] updateMatrix(int[][] mat) { int m = mat.length; int n = mat[0].length; int dp[][] = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (mat[i][j] == 0) continue; if (i == 0 \u0026amp;\u0026amp; j == 0 \u0026amp;\u0026amp; mat[0][0] != 0) { dp[0][0] = m + n; continue; } int up = (i == 0 ? m + n : dp[i - 1][j]); int left = (j == 0 ? m + n : dp[i][j - 1]); dp[i][j] = Math.min(up, left) + 1; } } for (int i = m - 1; i \u0026gt;= 0; i--) { for (int j = n - 1; j \u0026gt;= 0; j--) { if (i == m - 1 \u0026amp;\u0026amp; j == n - 1) continue; int down = (i == m - 1 ? m + n : dp[i + 1][j]); int right = (j == n - 1 ? m + n : dp[i][j + 1]); dp[i][j] = Math.min(dp[i][j], Math.min(down, right) + 1); } } return dp; } } 背包 背包问题总结：『 一文搞懂完全背包问题 』从0-1背包到完全背包，逐层深入+数学推导 - 最少的硬币数目 - 力扣（LeetCode）\n最少的硬币数目(完全背包数个数) 1 2 3 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 你可以认为每种硬币的数量是无限的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int k = 0; k \u0026lt; coins.length; k++) { for (int i = 1; i \u0026lt;= amount; i++) { if (i - coins[k] \u0026lt; 0 || dp[i - coins[k]] == Integer.MAX_VALUE) continue; dp[i] = Math.min(dp[i], dp[i - coins[k]] + 1); } } return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount]; } } public int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for (int i = 1; i \u0026lt;= amount; i++) { for (int k = 0; k \u0026lt; coins.length; k++) { if (i - coins[k] \u0026lt; 0 || dp[i - coins[k]] == Integer.MAX_VALUE) continue; dp[i] = Math.min(dp[i], dp[i - coins[k]] + 1); } } return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount]; } 背包变体：剑指 Offer II 102. 加减的目标值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int ele : nums) sum += ele; if (target \u0026gt; sum || target \u0026lt; sum * -1) return 0; int[][] dp = new int[nums.length + 1][sum * 2 + 1]; dp[0][sum] = 1; for (int i = 1; i \u0026lt;= nums.length; i++) { for (int j = 0; j \u0026lt; sum * 2 + 1; j++) { int tmp = 0; // nums[i - 1]为当前元素 if (j - nums[i - 1] \u0026gt;= 0) tmp += dp[i - 1][j - nums[i - 1]]; if (j + nums[i - 1] \u0026lt; sum * 2 + 1) tmp += dp[i - 1][j + nums[i - 1]]; dp[i][j] = tmp; } } return dp[nums.length][target + sum]; } } //优化：只考虑正或负 class Solution { public int findTargetSumWays(int[] nums, int target) { int sum = 0; for (int ele : nums) sum += ele; if (target \u0026gt; sum || target \u0026lt; sum * -1 || (target + sum) % 2 == 1) return 0; int pos = (target + sum) / 2; int[][] dp = new int[nums.length + 1][pos + 1]; dp[0][0] = 1; for (int i = 1; i \u0026lt;= nums.length; i++) { for (int j = 0; j \u0026lt; pos + 1; j++) { dp[i][j] += dp[i - 1][j]; if (j - nums[i - 1] \u0026gt;= 0) { dp[i][j] += dp[i - 1][j - nums[i - 1]]; } } } return dp[nums.length][pos]; } } 关联题目：416. 分割等和子集\n少状态DP 买卖股票的最佳时机 II 1 2 3 4 5 6 7 8 9 10 11 public int maxProfit(int[] prices) { int[] buy = new int[prices.length]; int[] sell = new int[prices.length]; buy[0] = -1 * prices[0]; sell[0] = 0; for (int i = 1; i \u0026lt; prices.length; i++) { buy[i] = Math.max(sell[i - 1] - prices[i], buy[i - 1]); sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]); } return sell[prices.length - 1]; } 两个状态，持有股票和不持有股票\n乘积最大子数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int maxProduct(int[] nums) { int positiveMax = 0; int negativeMax = 0; int maximun = nums[0]; int tmp = 0; if (maximun \u0026gt; 0) positiveMax = maximun; else negativeMax = maximun; for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] \u0026gt; 0) { negativeMax = negativeMax * nums[i]; positiveMax = Math.max(positiveMax * nums[i], nums[i]); } else if (nums[i] \u0026lt; 0) { tmp = negativeMax * nums[i]; negativeMax = Math.min(positiveMax * nums[i], nums[i]); positiveMax = tmp; } else { negativeMax = 0; positiveMax = 0; } maximun = Math.max(maximun, positiveMax); } return maximun; } } ","date":"2022-06-12T21:20:31+08:00","permalink":"https://hifing.github.io/p/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"动态规划"}]